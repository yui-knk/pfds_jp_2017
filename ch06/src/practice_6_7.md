# BottomUpMergeSortの解説

emptyに対して、`1, 3, 2, 4`の順にaddしたとき。
`[(1)]`はそのリストの要素数が1つということを意味する。

(注) 実際は遅延計算

n = 1  [(1)]                 : [1] 
n = 2  [(1)], [(1)] -> [(2)] : [1, 3]
n = 3  [(1)], [(2)]          : [2], [1, 3]
n = 4  [(2)], [(2)] -> [(4)] : [2, 4], [1, 3] -> [1, 2, 3, 4]

* mrgはセグメント同士のMergeである。
* この構造で要素の比較を行っているのは`mrg`のみである。
* 遅延が発生するのは`add`をしたときで、実行がおきるのは`sort`をしたときである。
* list suspを使用しているので、これは一枚岩である。

`n = 3`のときに`add(4, s)`してみる。
`size = 3`なので

`add(4, (3, [[2], [1, 3]]))`
`in (3 + 1, $(addSeg ([4], force [[2], [1, 3]], 3)))`

となる。
`addSeg`に注目すると、sizeが3や5などの奇数のときは(下位1bitがたち、lenが1のlistがいるので)
`[4]`と`[2]`をmergeする必要がある。
すると次の`addSeg`の呼び出しは、

`addSeg ([2, 4], [1, 3], 1)`

となる。ここで第三引数の`size`が3から1になったのは、ビットを1つ右シフトして、
次の桁でmergeが必要かチェックしていることに相当する。

## addの償却コスト

### 二進数と(2 ^ i)の割り算

二進数上で考えたとき、(2 ^ i)で割り算するということは
i桁目で分断して、左側を商、右側を余りとすることと同じである。

例: 7 (10)のとき

111 (2)と表現される。

これを (2^0), (2^1), (2^2)で割ることを考える。

| 式         | 商          |  余り         |
|:-----------|------------:|-------------:|
| 111 / (2^0)| 111 (2)     |  0 (2)       |
| 111 / (2^1)| 110 (2)     |  1 (2)       |
| 111 / (2^2)| 100 (2)     | 11 (2)       |

つまり`111 (2)`を`(2^2)`で割る時は

```
111
 ^~~ ここで分割
```

### 本題

* `(n mod 2^i + 1)`の結合は`((n mod 2^i) + 1)`である(P.78の"(i < k)の場合"より)。

`n`を以下のように表現している。

1....011...1
     ^~~ bk

このとき`n + 1 = n'`は以下のようになる。
なお`bk`の地点より上では繰り上がりがないため、`bk`より
上位のbitは`n`も`n'`も共通である。

1....100...0
     ^~~ bk

δ(i)の場合分けは以下の通り。なお、

`bi(n mod 2^i + 1) - bi'(n' mod 2^i + 1)`の
`bi(n mod 2^i + 1)`を(左)、
`bi'(n' mod 2^i + 1)`を(右)と呼ぶ。

* (i < k)のとき

`n`の側は常に1がたち、`n'`の側は常に0である。
よって、(左)のみ計算すればいい。

* (i = k)のとき

`n`の側は0で、`n'`の側は1である。
よって(右)のみ計算すればいい。

* (i > k)のとき

`n`の側と、`n'`の側は常に同じである(両方とも1、もしくは両方とも0)。
よって`bi = bi'`となる。`δ(i)`の`bi`を`bi'`で置き換えて、

```
δ(i)
= bi'(n mod 2^i + 1) - bi'(n' mod 2^i + 1)
= bi'(n mod 2^i - n' mod 2^i) ...(A)
```

`n`は

1....011...1
     ^~~ bk

`n'`は

1....100...0
     ^~~ bk

`bk`より上位bitで分割したとき(`mod 2^i`)は

`n`は

abcde011...1
     ^~~ bk

`n'`は

abcde100...0
     ^~~ bk

`abcde`は共通なので、(A)は`-1`となる。

# 演習 6.7

## memo

* セグメントをストリームで実装する。
* mrgはセグメント同士のMergeであるので、ストリームの結合になる。

## add

非共有コストのみが異なるので、非共有コストを計算する。
"リストの停止リスト"のときは、

`in (size + 1, $(addSeg ([x], force segs, size))) end`

で即座に計算が止まっていた。
一方で、"ストリームのリスト"のときは、`addSeg`は再起的に呼び続けられる。
`segs`は長くても`log n`程度なので、非共有コストは`log n`。
このとき完全コストは、`2^(k+1) -2 + (log n)`。
償却コストは`2^(k+1) -2 + (log n) - (2^(k+1) - 2B') = 2B' + (log n) -2`。
よって、O(log n)である。

## sort

`mrg`がlazyなので"オブジェクト内の停止計算を進行させたい(P. 70)"わけではない。
よって、O(n)。

# (b)

完全コストはk。
ポテンシャルの変化量は`add`の逆なので、``

