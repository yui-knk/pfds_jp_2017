# BottomUpMergeSortの解説

emptyに対して、`1, 3, 2, 4`の順にaddしたとき。
`[(1)]`はそのリストの要素数が1つということを意味する。

(注) 実際は遅延計算

n = 1  [(1)]                 : [1] 
n = 2  [(1)], [(1)] -> [(2)] : [1, 3]
n = 3  [(1)], [(2)]          : [2], [1, 3]
n = 4  [(2)], [(2)] -> [(4)] : [2, 4], [1, 3] -> [1, 2, 3, 4]

* mrgはセグメント同士のMergeである。
* この構造で要素の比較を行っているのは`mrg`のみである。
* 遅延が発生するのは`add`をしたときで、実行がおきるのは`sort`をしたときである。
* list suspを使用しているので、これは一枚岩である。

`n = 3`のときに`add(4, s)`してみる。
`size = 3`なので

`add(4, (3, [[2], [1, 3]]))`
`in (3 + 1, $(addSeg ([4], force [[2], [1, 3]], 3)))`

となる。
`addSeg`に注目すると、sizeが3や5などの奇数のときは(下位1bitがたち、lenが1のlistがいるので)
`[4]`と`[2]`をmergeする必要がある。
すると次の`addSeg`の呼び出しは、

`addSeg ([2, 4], [1, 3], 1)`

となる。ここで第三引数の`size`が3から1になったのは、ビットを1つ右シフトして、
次の桁でmergeが必要かチェックしていることに相当する。


# 演習 6.7

## memo

* セグメントをストリームで実装する。
* mrgはセグメント同士のMergeであるので、ストリームの結合になる。

## add

非共有コストのみが異なるので、非共有コストを計算する。
"リストの停止リスト"のときは、

`in (size + 1, $(addSeg ([x], force segs, size))) end`

で即座に計算が止まっていた。
一方で、"ストリームのリスト"のときは、`addSeg`は再起的に呼び続けられる。
`segs`は長くても`log n`程度なので、非共有コストは`log n`。
このとき完全コストは、`2^(k+1) -2 + (log n)`。
償却コストは`2^(k+1) -2 + (log n) - (2^(k+1) - 2B') = 2B' + (log n) -2`。
よって、O(log n)である。

## sort

`mrg`がlazyなので"オブジェクト内の停止計算を進行させたい(P. 70)"わけではない。
よって、O(n)。


