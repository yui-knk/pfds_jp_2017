## memo

サイズnのheapに対して、ポテンシャル関数を Z(n) とする。
Z(n) は n を二進数表記したときの 0 の個数。

  償却コスト = 完全コスト - ポテンシャルの変化量

なので、0が増えるときには償却コストはより小さくなり、
0が減るときには償却コストはより大きくなる。
これはlinkがコスト増加の原因であり、1が増えるほど
linkをする可能性が高まるから、1が増加した時点に
負債返却をさせるための設計だと思う。


## merge

ts1, ts2 をmergeするとする。
それぞれの桁数を l1, l2 とする。
それぞれのサイズを n1, n2 とする。
mergeの中で k 回の link を行うとする。

l1 >= l2 となるように ts1, ts2 を必要なら交換する。

このときそれぞれの二進数表記上の0の数は、 Z(n1), Z(n2) 。
このときそれぞれの二進数表記上の1の数は、 l1 - Z(n1), l2 - Z(n2) 。

merge後の桁数 l3 は l1 もしくは l1+1。ここで0もしくは1の数、 a を用いて

  l3 = l1 + a

merge後の二進数表記上の1の数は、

  (l1 - Z(n1)) + (l2 - Z(n2)) - k  ..(A)

merge後の二進数表記上の0の数は、

  (l1 + a) - ((l1 - Z(n1)) + (l2 - Z(n2)) - k)

  = a + Z(n1) + Z(n2) - l2 + k ..(B)

ポテンシャルの変化量は

  (B) - (Z(n1) + Z(n2))

  = (a + Z(n1) + Z(n2) - l2 + k) - (Z(n1) + Z(n2))

  = a - l2 + k  ..(C)

mergeの完全コストは、5.3にもあるように、

  log(n1) + log(n2) + k

  = l1 + l2 + k  ..(D)

よって、償却コストは

  (D) - (C)

  (l1 + l2 + k) - (a - l2 + k)

  = l1 - a  ..(E)

これは O(log n) に収まる。


## deleteMin

5.3と同様に。

removeMinTreeのコストは木の個数 t と同じなので、"log n"。
ヒープの要素数が n のとき、もっとも大きい木を `rev ts1` したとしても "-1 + log(n+1)"。
mergeは上記の通り、"log n"に収まる。

よってたかだか "3 * log n"程度。


## findMin

"オブジェクトのポテンシャルが0でないときにそのオブジェクトの停止計算を進行"させるときには
"オブジェクトのポテンシャルを償却コストに足し合わせる"という点に注意する。

桁数を l とする。
サイズを n とする。

このとき二進数表記上の0の数は、 Z(n)。
このとき二進数表記上の1の数は、 l - Z(n)。

完全コストは、1の数に等しいので

  l - Z(n)  ..(A)

オブジェクトのポテンシャルは

  Z(n)  ..(B)

よって償却コストは

  (A) + (B)

  = l

これは O(log n) に収まる。
